#!/usr/bin/env python3
"""
Convert coil JSON files to DXF format.

This script reads a coil JSON file (generated by gen_*_coil.py scripts) and
exports the track geometry to a DXF file for use in CAD applications.
"""

import json
import argparse
import os
try:
    import ezdxf
except ImportError:
    print("Error: ezdxf library is required. Install it with: pip install ezdxf")
    exit(1)


def coil_json_to_dxf(json_path, dxf_path=None, layer_mapping=None):
    """
    Convert a coil JSON file to DXF format.

    Args:
        json_path (str): Path to the input JSON file
        dxf_path (str): Path to the output DXF file (optional, auto-generated if None)
        layer_mapping (dict): Mapping of JSON layers to DXF layer names (optional)

    Returns:
        str: Path to the generated DXF file
    """
    # Default layer mapping
    if layer_mapping is None:
        layer_mapping = {
            'f': 'FRONT',
            'b': 'BACK',
            'in': 'INNER',
            'vias': 'VIAS',
            'pads': 'PADS',
            'edgeCuts': 'EDGE_CUTS'
        }

    # Load the JSON file
    with open(json_path, 'r') as f:
        coil_data = json.load(f)

    # Generate output path if not provided
    if dxf_path is None:
        base_name = os.path.splitext(json_path)[0]
        dxf_path = f"{base_name}.dxf"

    # Create a new DXF document
    doc = ezdxf.new('R2010')
    msp = doc.modelspace()

    # Get track parameters
    params = coil_data.get('parameters', {})
    default_track_width = params.get('trackWidth', 0.15)

    # Add layers
    for layer_name in layer_mapping.values():
        doc.layers.new(name=layer_name)

    # Process tracks
    tracks = coil_data.get('tracks', {})

    # Front layer tracks
    for track in tracks.get('f', []):
        points = track.get('pts', [])
        track_width = track.get('width', default_track_width)
        layer_name = layer_mapping['f']
        _add_polyline(msp, points, layer_name, track_width)

    # Back layer tracks
    for track in tracks.get('b', []):
        points = track.get('pts', [])
        track_width = track.get('width', default_track_width)
        layer_name = layer_mapping['b']
        _add_polyline(msp, points, layer_name, track_width)

    # Inner layer tracks
    inner_tracks = tracks.get('in', [])
    for i, layer_tracks in enumerate(inner_tracks):
        for track in layer_tracks:
            points = track.get('pts', [])
            track_width = track.get('width', default_track_width)
            layer_name = f"{layer_mapping['in']}_{i+1}"
            # Create layer if it doesn't exist
            if layer_name not in doc.layers:
                doc.layers.new(name=layer_name)
            _add_polyline(msp, points, layer_name, track_width)

    # Add vias
    vias = coil_data.get('vias', [])
    via_diam = params.get('viaDiameter', 0.8)
    for via in vias:
        x, y = via['x'], via['y']
        msp.add_circle((x, y), via_diam / 2, dxfattribs={'layer': layer_mapping['vias']})

    # Add pads
    pads = coil_data.get('pads', [])
    for pad in pads:
        x, y = pad['x'], pad['y']
        width, height = pad['width'], pad['height']
        angle = pad.get('angle', 0)

        # Create rectangle as closed polyline
        half_w, half_h = width / 2, height / 2
        corners = [
            (-half_w, -half_h),
            (half_w, -half_h),
            (half_w, half_h),
            (-half_w, half_h),
            (-half_w, -half_h)
        ]

        # Rotate and translate corners
        import math
        rad = math.radians(angle)
        cos_a, sin_a = math.cos(rad), math.sin(rad)

        rotated_corners = []
        for cx, cy in corners:
            rx = cx * cos_a - cy * sin_a + x
            ry = cx * sin_a + cy * cos_a + y
            rotated_corners.append((rx, ry))

        msp.add_lwpolyline(rotated_corners, dxfattribs={'layer': layer_mapping['pads']})

    # Add edge cuts
    edge_cuts = coil_data.get('edgeCuts', [])
    for edge in edge_cuts:
        _add_polyline(msp, edge, layer_mapping['edgeCuts'])

    # Save the DXF file
    doc.saveas(dxf_path)
    print(f"DXF file saved to: {dxf_path}")

    return dxf_path


def _add_polyline(msp, points, layer, width=None):
    """
    Add a polyline to the modelspace.

    Args:
        msp: Modelspace object
        points (list): List of point dictionaries with 'x' and 'y' keys
        layer (str): Layer name
        width (float): Line width (optional)
    """
    if not points or len(points) < 2:
        return

    # Convert points to tuples
    point_tuples = [(p['x'], p['y']) for p in points]

    # Create polyline
    if width is not None:
        # Use LWPOLYLINE with constant width
        polyline = msp.add_lwpolyline(point_tuples, dxfattribs={'layer': layer})
        polyline.dxf.const_width = width
    else:
        # Use simple LWPOLYLINE
        msp.add_lwpolyline(point_tuples, dxfattribs={'layer': layer})


def main():
    parser = argparse.ArgumentParser(
        description='Convert coil JSON files to DXF format',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python coil_to_dxf.py coil_json/ellipse_w0.15_s0.30_t10.json
  python coil_to_dxf.py coil_json/my_coil.json -o output.dxf
        """
    )
    parser.add_argument('input', help='Input JSON file path')
    parser.add_argument('-o', '--output', help='Output DXF file path (default: same as input with .dxf extension)')

    args = parser.parse_args()

    # Check if input file exists
    if not os.path.exists(args.input):
        print(f"Error: Input file '{args.input}' not found")
        exit(1)

    # Convert to DXF
    coil_json_to_dxf(args.input, args.output)


if __name__ == '__main__':
    main()
